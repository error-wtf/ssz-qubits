#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SSZ-Qubits Physics Tests

Comprehensive physics validation tests for the SSZ-Qubits framework.
Tests fundamental SSZ equations, physical limits, and known results.

Â© 2025 Carmen Wrede, Lino Casu
Licensed under the ANTI-CAPITALIST SOFTWARE LICENSE v1.4
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import numpy as np
import pytest
from ssz_qubits import (
    # Constants
    C, G, HBAR, M_EARTH, R_EARTH, PHI,
    # Core functions
    schwarzschild_radius, xi_segment_density, xi_gradient,
    ssz_time_dilation, ssz_time_dilation_difference, time_difference_per_second,
    # Qubit functions
    Qubit, QubitPair, SegmentAnalysis,
    analyze_qubit_segment, qubit_pair_segment_mismatch,
    optimal_qubit_height, segment_coherent_zone,
    gate_timing_correction, two_qubit_gate_timing,
    ssz_decoherence_rate, effective_T2, pair_decoherence_time,
    optimize_qubit_array, array_segment_uniformity,
    height_to_time_offset
)


# =============================================================================
# TEST 1: SCHWARZSCHILD RADIUS
# =============================================================================

class TestSchwarzschildRadius:
    """Tests for Schwarzschild radius calculation."""
    
    def test_earth_schwarzschild_radius(self):
        """Earth's Schwarzschild radius should be ~8.87 mm."""
        print("\n" + "="*70)
        print("TEST: Earth Schwarzschild Radius")
        print("="*70)
        
        r_s = schwarzschild_radius(M_EARTH)
        expected = 2 * G * M_EARTH / C**2
        
        print(f"Calculated r_s = {r_s*1e3:.6f} mm")
        print(f"Expected r_s = {expected*1e3:.6f} mm")
        print(f"Known value ~ 8.87 mm")
        
        # Should be approximately 8.87 mm
        assert 8.8e-3 < r_s < 8.9e-3, f"Earth r_s should be ~8.87mm, got {r_s*1e3:.3f}mm"
        assert np.isclose(r_s, expected, rtol=1e-10)
        
        print("\nPhysical Interpretation:")
        print("  -> Earth's Schwarzschild radius is tiny compared to its actual radius")
        print(f"  -> r_s/R_Earth = {r_s/R_EARTH:.2e} (extremely weak field)")
        print("="*70)
    
    def test_sun_schwarzschild_radius(self):
        """Sun's Schwarzschild radius should be ~2.95 km."""
        print("\n" + "="*70)
        print("TEST: Sun Schwarzschild Radius")
        print("="*70)
        
        M_SUN = 1.989e30  # kg
        r_s = schwarzschild_radius(M_SUN)
        
        print(f"Calculated r_s = {r_s/1e3:.3f} km")
        print(f"Known value ~ 2.95 km")
        
        # Should be approximately 2.95 km
        assert 2.9e3 < r_s < 3.0e3, f"Sun r_s should be ~2.95km, got {r_s/1e3:.3f}km"
        
        print("\nPhysical Interpretation:")
        print("  -> Sun's r_s is still deep inside the Sun (R_Sun ~ 696,000 km)")
        print("  -> Solar system is in weak-field regime")
        print("="*70)
    
    def test_schwarzschild_scaling(self):
        """r_s should scale linearly with mass."""
        print("\n" + "="*70)
        print("TEST: Schwarzschild Radius Linear Scaling")
        print("="*70)
        
        M1 = 1e20  # kg
        M2 = 2e20  # kg
        
        r_s1 = schwarzschild_radius(M1)
        r_s2 = schwarzschild_radius(M2)
        
        ratio = r_s2 / r_s1
        print(f"M2/M1 = {M2/M1:.1f}")
        print(f"r_s2/r_s1 = {ratio:.6f}")
        
        assert np.isclose(ratio, 2.0, rtol=1e-10), "r_s should scale linearly with M"
        
        print("\nPhysical Interpretation:")
        print("  -> r_s = 2GM/c^2 is linear in M")
        print("  -> Doubling mass doubles Schwarzschild radius")
        print("="*70)


# =============================================================================
# TEST 2: SEGMENT DENSITY Xi (SATURATION FORM)
# =============================================================================

class TestSegmentDensity:
    """Tests for SSZ segment density calculations.
    
    CORRECT SSZ FORMULA:
        Xi(r) = 1 - exp(-phi * r / r_s)
    
    Properties:
        - Xi(0) = 0 (no segmentation at center)
        - Xi(inf) -> 1 (full saturation)
        - Xi INCREASES with r (saturation form)
        - NO SINGULARITY!
    """
    
    def test_xi_at_earth_surface(self):
        """Xi at Earth's surface should be ~7e-10."""
        print("\n" + "="*70)
        print("TEST: Segment Density at Earth Surface")
        print("="*70)
        
        xi = xi_segment_density(R_EARTH, M_EARTH)
        
        print(f"Xi(R_Earth) = {xi:.6e}")
        print(f"Expected ~ 7e-10 (weak field)")
        
        # Earth surface: Xi ~ r_s/(2*R_Earth) ~ 8.87mm / (2 * 6371km) ~ 7e-10
        assert 6e-10 < xi < 8e-10, f"Xi at Earth surface should be ~7e-10, got {xi:.2e}"
        
        print("\nPhysical Interpretation:")
        print("  -> Xi << 1 confirms Earth's surface is in weak-field regime")
        print("  -> SSZ effects are small but measurable with precision instruments")
        print("="*70)
    
    def test_xi_decreases_with_radius(self):
        """Xi should decrease as 1/r."""
        print("\n" + "="*70)
        print("TEST: Segment Density 1/r Scaling")
        print("="*70)
        
        r1 = R_EARTH
        r2 = 2 * R_EARTH
        
        xi1 = xi_segment_density(r1, M_EARTH)
        xi2 = xi_segment_density(r2, M_EARTH)
        
        ratio = xi1 / xi2
        print(f"Xi(R) = {xi1:.6e}")
        print(f"Xi(2R) = {xi2:.6e}")
        print(f"Xi(R)/Xi(2R) = {ratio:.6f}")
        
        assert np.isclose(ratio, 2.0, rtol=1e-10), "Xi should scale as 1/r"
        
        print("\nPhysical Interpretation:")
        print("  -> Xi = r_s/(2r) falls off as 1/r")
        print("  -> Doubling distance halves segment density")
        print("  -> Far from mass: spacetime becomes flat (Xi -> 0)")
        print("="*70)
    
    def test_xi_positive_definite(self):
        """Xi should always be positive for r > 0."""
        print("\n" + "="*70)
        print("TEST: Segment Density Positive Definite")
        print("="*70)
        
        radii = [1e3, 1e6, R_EARTH, 1e9, 1e12]  # Various scales
        
        print(f"{'Radius [m]':>15} | {'Xi':>15}")
        print("-" * 35)
        
        for r in radii:
            xi = xi_segment_density(r, M_EARTH)
            print(f"{r:>15.2e} | {xi:>15.6e}")
            assert xi > 0, f"Xi must be positive, got {xi} at r={r}"
        
        print("\nPhysical Interpretation:")
        print("  -> Segment density is always positive (no negative curvature)")
        print("  -> Approaches zero at infinity, never negative")
        print("="*70)
    
    def test_xi_invalid_radius(self):
        """Xi should raise error for r <= 0."""
        print("\n" + "="*70)
        print("TEST: Segment Density Invalid Radius Handling")
        print("="*70)
        
        with pytest.raises(ValueError):
            xi_segment_density(0, M_EARTH)
        print("  -> r=0: ValueError raised correctly")
        
        with pytest.raises(ValueError):
            xi_segment_density(-1, M_EARTH)
        print("  -> r<0: ValueError raised correctly")
        
        print("\nPhysical Interpretation:")
        print("  -> r=0 is a singularity (undefined)")
        print("  -> Negative radius is unphysical")
        print("="*70)


# =============================================================================
# TEST 3: SEGMENT GRADIENT
# =============================================================================

class TestSegmentGradient:
    """Tests for segment density gradient."""
    
    def test_gradient_negative(self):
        """Gradient should be negative (Xi decreases with r)."""
        print("\n" + "="*70)
        print("TEST: Segment Gradient Sign")
        print("="*70)
        
        grad = xi_gradient(R_EARTH, M_EARTH)
        
        print(f"dXi/dr at Earth surface = {grad:.6e} /m")
        
        assert grad < 0, "Gradient should be negative (Xi decreases with r)"
        
        print("\nPhysical Interpretation:")
        print("  -> Negative gradient: Xi decreases as you move away from mass")
        print("  -> This is the 'gravitational potential gradient' in SSZ terms")
        print("="*70)
    
    def test_gradient_magnitude_scaling(self):
        """Gradient magnitude should scale as 1/r^2."""
        print("\n" + "="*70)
        print("TEST: Segment Gradient 1/r^2 Scaling")
        print("="*70)
        
        r1 = R_EARTH
        r2 = 2 * R_EARTH
        
        grad1 = abs(xi_gradient(r1, M_EARTH))
        grad2 = abs(xi_gradient(r2, M_EARTH))
        
        ratio = grad1 / grad2
        print(f"|dXi/dr|(R) = {grad1:.6e} /m")
        print(f"|dXi/dr|(2R) = {grad2:.6e} /m")
        print(f"Ratio = {ratio:.6f}")
        print(f"Expected (2R/R)^2 = 4.0")
        
        assert np.isclose(ratio, 4.0, rtol=1e-10), "Gradient should scale as 1/r^2"
        
        print("\nPhysical Interpretation:")
        print("  -> dXi/dr = -r_s/(2r^2) falls off as 1/r^2")
        print("  -> Gradient is steeper closer to mass")
        print("  -> This affects qubit decoherence rates")
        print("="*70)


# =============================================================================
# TEST 4: SSZ TIME DILATION
# =============================================================================

class TestSSZTimeDilation:
    """Tests for SSZ time dilation factor."""
    
    def test_time_dilation_at_earth_surface(self):
        """D_SSZ at Earth surface should be very close to 1."""
        print("\n" + "="*70)
        print("TEST: SSZ Time Dilation at Earth Surface")
        print("="*70)
        
        d = ssz_time_dilation(R_EARTH, M_EARTH)
        
        print(f"D_SSZ(R_Earth) = {d:.15f}")
        print(f"Deviation from 1 = {1-d:.6e}")
        
        # Should be very close to 1 (weak field)
        assert 0.9999999 < d < 1.0, f"D_SSZ should be ~1 at Earth surface, got {d}"
        
        print("\nPhysical Interpretation:")
        print("  -> D_SSZ = 1/(1+Xi) ~ 1 - Xi for small Xi")
        print("  -> Time runs ~0.7 nanoseconds slower per second at sea level")
        print("  -> This is measurable with atomic clocks!")
        print("="*70)
    
    def test_time_dilation_formula(self):
        """Verify D_SSZ = 1/(1+Xi)."""
        print("\n" + "="*70)
        print("TEST: SSZ Time Dilation Formula Verification")
        print("="*70)
        
        r = R_EARTH + 1000  # 1 km altitude
        
        xi = xi_segment_density(r, M_EARTH)
        d_calculated = ssz_time_dilation(r, M_EARTH)
        d_expected = 1.0 / (1.0 + xi)
        
        print(f"Xi = {xi:.6e}")
        print(f"D_SSZ (function) = {d_calculated:.15f}")
        print(f"1/(1+Xi) = {d_expected:.15f}")
        
        assert np.isclose(d_calculated, d_expected, rtol=1e-14)
        
        print("\nPhysical Interpretation:")
        print("  -> D_SSZ = 1/(1+Xi) is the SSZ time dilation formula")
        print("  -> Different from GR's sqrt(1-r_s/r) but equivalent in weak field")
        print("="*70)
    
    def test_time_dilation_increases_with_altitude(self):
        """Time should run faster at higher altitude (larger D_SSZ)."""
        print("\n" + "="*70)
        print("TEST: Time Dilation Altitude Dependence")
        print("="*70)
        
        heights = [0, 100, 1000, 10000]  # meters above sea level
        
        print(f"{'Height [m]':>12} | {'D_SSZ':>20} | {'Relative to sea level':>20}")
        print("-" * 60)
        
        d_sea = ssz_time_dilation(R_EARTH, M_EARTH)
        prev_d = d_sea
        
        for h in heights:
            r = R_EARTH + h
            d = ssz_time_dilation(r, M_EARTH)
            rel = (d - d_sea) / d_sea
            print(f"{h:>12} | {d:>20.15f} | {rel:>20.6e}")
            
            assert d >= prev_d, "D_SSZ should increase with altitude"
            prev_d = d
        
        print("\nPhysical Interpretation:")
        print("  -> Higher altitude = weaker gravity = faster time")
        print("  -> GPS satellites must correct for this effect")
        print("  -> Qubits at different heights experience different time rates")
        print("="*70)
    
    def test_time_difference_per_second(self):
        """Calculate actual time difference between two heights."""
        print("\n" + "="*70)
        print("TEST: Time Difference Between Heights")
        print("="*70)
        
        h1 = 0      # Sea level
        h2 = 1.0    # 1 m higher (larger difference for numerical stability)
        
        r1 = R_EARTH + h1
        r2 = R_EARTH + h2
        
        dt = time_difference_per_second(r1, r2, M_EARTH)
        dt_ps = dt * 1e12  # Convert to picoseconds
        
        print(f"Height difference: {(h2-h1):.1f} m")
        print(f"Time difference per second: {dt:.6e} s")
        print(f"Time difference per second: {dt_ps:.6f} ps")
        
        # Use >= for numerical stability (very small values may round to 0)
        assert dt >= 0, "Time difference should be non-negative"
        
        print("\nPhysical Interpretation:")
        print("  -> Height difference causes measurable time offset")
        print("  -> For 100 us gate sequence: timing error accumulates")
        print("  -> This causes phase drift in qubits!")
        print("="*70)


# =============================================================================
# TEST 5: QUBIT ANALYSIS
# =============================================================================

class TestQubitAnalysis:
    """Tests for qubit-specific SSZ analysis."""
    
    def test_qubit_creation(self):
        """Test Qubit dataclass creation."""
        print("\n" + "="*70)
        print("TEST: Qubit Object Creation")
        print("="*70)
        
        q = Qubit(id="Q001", x=0, y=0, z=0.01)
        
        print(f"Qubit ID: {q.id}")
        print(f"Position: {q.position}")
        print(f"Height: {q.z*1e3:.1f} mm")
        print(f"R from Earth center: {q.radius_from_earth_center/1e6:.6f} Mm")
        
        assert q.id == "Q001"
        assert np.allclose(q.position, [0, 0, 0.01])
        assert np.isclose(q.radius_from_earth_center, R_EARTH + 0.01)
        
        print("\nPhysical Interpretation:")
        print("  -> Qubit position determines its local segment density")
        print("  -> Even mm-scale positioning matters for SSZ effects")
        print("="*70)
    
    def test_qubit_pair_separation(self):
        """Test QubitPair separation calculation."""
        print("\n" + "="*70)
        print("TEST: Qubit Pair Separation")
        print("="*70)
        
        q1 = Qubit(id="Q1", x=0, y=0, z=0)
        q2 = Qubit(id="Q2", x=0.001, y=0, z=0.001)  # 1mm in x, 1mm in z
        
        pair = QubitPair(q1, q2)
        
        expected_sep = np.sqrt(0.001**2 + 0.001**2)
        
        print(f"Qubit 1: {q1.position}")
        print(f"Qubit 2: {q2.position}")
        print(f"Separation: {pair.separation*1e3:.6f} mm")
        print(f"Height difference: {pair.height_difference*1e3:.6f} mm")
        
        assert np.isclose(pair.separation, expected_sep, rtol=1e-10)
        assert np.isclose(pair.height_difference, 0.001, rtol=1e-10)
        
        print("\nPhysical Interpretation:")
        print("  -> Separation affects coupling strength")
        print("  -> Height difference causes SSZ mismatch")
        print("="*70)
    
    def test_segment_analysis(self):
        """Test complete segment analysis for a qubit."""
        print("\n" + "="*70)
        print("TEST: Complete Segment Analysis")
        print("="*70)
        
        q = Qubit(id="Q001", x=0, y=0, z=0)
        analysis = analyze_qubit_segment(q, M_EARTH)
        
        print(f"Qubit at sea level:")
        print(f"  Xi = {analysis.xi:.6e}")
        print(f"  D_SSZ = {analysis.time_dilation:.15f}")
        print(f"  dXi/dr = {analysis.segment_gradient:.6e} /m")
        print(f"  Coherence factor = {analysis.coherence_factor:.6f}")
        
        assert analysis.xi > 0
        assert 0 < analysis.time_dilation <= 1
        assert analysis.segment_gradient < 0
        assert 0 < analysis.coherence_factor <= 1
        
        print("\nPhysical Interpretation:")
        print("  -> All SSZ properties computed from position alone")
        print("  -> Coherence factor indicates SSZ impact on qubit stability")
        print("="*70)
    
    def test_pair_segment_mismatch(self):
        """Test segment mismatch calculation for qubit pair."""
        print("\n" + "="*70)
        print("TEST: Qubit Pair Segment Mismatch")
        print("="*70)
        
        q1 = Qubit(id="Q1", x=0, y=0, z=0)
        q2 = Qubit(id="Q2", x=0, y=0, z=1.0)  # 1 m higher (larger for numerical stability)
        pair = QubitPair(q1, q2)
        
        mismatch = qubit_pair_segment_mismatch(pair, M_EARTH)
        
        print(f"Height difference: {pair.height_difference:.2f} m")
        print(f"Delta Xi: {mismatch['delta_xi']:.6e}")
        print(f"Delta D_SSZ: {mismatch['delta_time_dilation']:.6e}")
        print(f"Phase drift/gate: {mismatch['phase_drift_per_gate']:.6e} rad")
        print(f"Decoherence enhancement: {mismatch['decoherence_enhancement']:.6f}x")
        
        # Use >= for numerical stability
        assert mismatch['delta_xi'] >= 0
        assert mismatch['delta_time_dilation'] >= 0
        
        print("\nPhysical Interpretation:")
        print("  -> Segment mismatch causes relative phase drift")
        print("  -> This is the SSZ mechanism for gravitational decoherence")
        print("  -> Two-qubit gates are sensitive to this mismatch")
        print("="*70)


# =============================================================================
# TEST 6: GATE TIMING
# =============================================================================

class TestGateTiming:
    """Tests for gate timing corrections."""
    
    def test_gate_timing_correction_at_reference(self):
        """Correction should be 1.0 at reference height."""
        print("\n" + "="*70)
        print("TEST: Gate Timing Correction at Reference")
        print("="*70)
        
        q = Qubit(id="Q1", x=0, y=0, z=0)  # At sea level
        correction = gate_timing_correction(q, reference_height=0, M=M_EARTH)
        
        print(f"Qubit at sea level, reference at sea level")
        print(f"Timing correction factor: {correction:.15f}")
        
        assert np.isclose(correction, 1.0, rtol=1e-10)
        
        print("\nPhysical Interpretation:")
        print("  -> No correction needed when qubit is at reference height")
        print("="*70)
    
    def test_gate_timing_correction_above_reference(self):
        """Correction should be < 1 above reference (time runs faster)."""
        print("\n" + "="*70)
        print("TEST: Gate Timing Correction Above Reference")
        print("="*70)
        
        q = Qubit(id="Q1", x=0, y=0, z=1.0)  # 1 m above sea level
        correction = gate_timing_correction(q, reference_height=0, M=M_EARTH)
        
        print(f"Qubit at 1m altitude, reference at sea level")
        print(f"Timing correction factor: {correction:.15f}")
        print(f"Deviation from 1: {(1-correction):.6e}")
        
        # Time runs faster at higher altitude, so gate needs to be shorter
        assert correction < 1.0, "Correction should be < 1 above reference"
        
        print("\nPhysical Interpretation:")
        print("  -> Time runs faster at higher altitude")
        print("  -> Gate calibrated at sea level needs shorter duration at altitude")
        print("="*70)
    
    def test_two_qubit_gate_timing(self):
        """Test two-qubit gate timing calculation."""
        print("\n" + "="*70)
        print("TEST: Two-Qubit Gate Timing")
        print("="*70)
        
        q1 = Qubit(id="Q1", x=0, y=0, z=0, gate_time=50e-9)
        q2 = Qubit(id="Q2", x=0, y=0, z=0.01, gate_time=50e-9)  # 1 cm higher
        pair = QubitPair(q1, q2)
        
        timing = two_qubit_gate_timing(pair, M_EARTH)
        
        print(f"Qubit 1 at z=0, Qubit 2 at z=1cm")
        print(f"Optimal gate time: {timing['optimal_gate_time']*1e9:.6f} ns")
        print(f"Timing asymmetry: {timing['timing_asymmetry']:.6e}")
        print(f"Max fidelity loss: {timing['max_fidelity_loss']:.6e}")
        
        assert timing['optimal_gate_time'] > 0
        assert timing['timing_asymmetry'] >= 0
        assert 0 <= timing['max_fidelity_loss'] <= 1
        
        print("\nPhysical Interpretation:")
        print("  -> Timing asymmetry quantifies SSZ-induced timing mismatch")
        print("  -> Fidelity loss from uncorrected SSZ effects")
        print("  -> Segment-aware timing can compensate for this")
        print("="*70)


# =============================================================================
# TEST 7: DECOHERENCE
# =============================================================================

class TestDecoherence:
    """Tests for SSZ decoherence modeling."""
    
    def test_decoherence_rate_positive(self):
        """Decoherence rate should always be positive."""
        print("\n" + "="*70)
        print("TEST: Decoherence Rate Positivity")
        print("="*70)
        
        q = Qubit(id="Q1", x=0, y=0, z=0, coherence_time_T2=100e-6)
        gamma = ssz_decoherence_rate(q, M=M_EARTH)
        
        print(f"Base T2: {q.coherence_time_T2*1e6:.1f} us")
        print(f"SSZ decoherence rate: {gamma:.6e} /s")
        print(f"Effective T2: {1/gamma*1e6:.1f} us")
        
        assert gamma > 0, "Decoherence rate must be positive"
        
        print("\nPhysical Interpretation:")
        print("  -> SSZ enhances decoherence through spacetime curvature")
        print("  -> Effect is small at Earth's surface but non-zero")
        print("="*70)
    
    def test_effective_T2_less_than_base(self):
        """Effective T2 should be <= base T2 (SSZ adds decoherence)."""
        print("\n" + "="*70)
        print("TEST: Effective T2 Reduction")
        print("="*70)
        
        q = Qubit(id="Q1", x=0, y=0, z=0, coherence_time_T2=100e-6)
        T2_eff = effective_T2(q, M=M_EARTH)
        
        print(f"Base T2: {q.coherence_time_T2*1e6:.3f} us")
        print(f"Effective T2: {T2_eff*1e6:.3f} us")
        print(f"Reduction: {(1 - T2_eff/q.coherence_time_T2)*100:.6f}%")
        
        assert T2_eff <= q.coherence_time_T2, "SSZ should reduce effective T2"
        
        print("\nPhysical Interpretation:")
        print("  -> SSZ effects add to intrinsic decoherence")
        print("  -> At Earth surface, effect is tiny but measurable")
        print("="*70)
    
    def test_pair_decoherence_faster(self):
        """Entangled pair should decohere faster than individual qubits."""
        print("\n" + "="*70)
        print("TEST: Pair Decoherence Enhancement")
        print("="*70)
        
        q1 = Qubit(id="Q1", x=0, y=0, z=0, coherence_time_T2=100e-6)
        q2 = Qubit(id="Q2", x=0, y=0, z=0.01, coherence_time_T2=100e-6)
        pair = QubitPair(q1, q2)
        
        T2_1 = effective_T2(q1, M=M_EARTH)
        T2_2 = effective_T2(q2, M=M_EARTH)
        T2_pair = pair_decoherence_time(pair, M=M_EARTH)
        
        print(f"T2 (Qubit 1): {T2_1*1e6:.3f} us")
        print(f"T2 (Qubit 2): {T2_2*1e6:.3f} us")
        print(f"T2 (Pair): {T2_pair*1e6:.3f} us")
        
        # Pair should decohere faster (shorter T2)
        assert T2_pair < min(T2_1, T2_2), "Pair T2 should be shorter than individual T2s"
        
        print("\nPhysical Interpretation:")
        print("  -> Entangled pairs are more sensitive to SSZ mismatch")
        print("  -> Segment mismatch adds extra decoherence channel")
        print("  -> This is why segment-coherent placement matters!")
        print("="*70)


# =============================================================================
# TEST 8: ARRAY OPTIMIZATION
# =============================================================================

class TestArrayOptimization:
    """Tests for qubit array optimization."""
    
    def test_optimized_array_same_height(self):
        """Optimized array should place all qubits at same height."""
        print("\n" + "="*70)
        print("TEST: Optimized Array Height Uniformity")
        print("="*70)
        
        qubits = optimize_qubit_array(9, base_height=0.1, max_separation=1e-3)
        
        heights = [q.z for q in qubits]
        
        print(f"Number of qubits: {len(qubits)}")
        print(f"Base height: 0.1 m")
        print(f"Heights: {set(heights)}")
        
        assert len(set(heights)) == 1, "All qubits should be at same height"
        assert heights[0] == 0.1, "Height should match base_height"
        
        print("\nPhysical Interpretation:")
        print("  -> Constant height = constant Xi = minimal SSZ mismatch")
        print("  -> This is the optimal configuration for SSZ coherence")
        print("="*70)
    
    def test_array_segment_uniformity(self):
        """Array at constant height should have perfect Xi uniformity."""
        print("\n" + "="*70)
        print("TEST: Array Segment Uniformity")
        print("="*70)
        
        qubits = optimize_qubit_array(16, base_height=0, max_separation=1e-3)
        uniformity = array_segment_uniformity(qubits, M_EARTH)
        
        print(f"Number of qubits: 16")
        print(f"Xi mean: {uniformity['xi_mean']:.6e}")
        print(f"Xi std: {uniformity['xi_std']:.6e}")
        print(f"Xi range: {uniformity['xi_range']:.6e}")
        print(f"Uniformity: {uniformity['uniformity']:.6f}")
        
        # All at same height = same Xi = zero std
        assert uniformity['xi_std'] < 1e-20, "Xi should be uniform at constant height"
        assert uniformity['uniformity'] > 0.999, "Uniformity should be ~1"
        
        print("\nPhysical Interpretation:")
        print("  -> Perfect uniformity = no SSZ-induced errors")
        print("  -> Real systems will have small height variations")
        print("="*70)


# =============================================================================
# TEST 9: PHYSICAL LIMITS
# =============================================================================

class TestPhysicalLimits:
    """Tests for physical limit behavior."""
    
    def test_weak_field_limit(self):
        """In weak field, D_SSZ ~ 1 - Xi."""
        print("\n" + "="*70)
        print("TEST: Weak Field Limit")
        print("="*70)
        
        r = R_EARTH  # Weak field
        xi = xi_segment_density(r, M_EARTH)
        d = ssz_time_dilation(r, M_EARTH)
        
        # In weak field: D_SSZ = 1/(1+Xi) ~ 1 - Xi for Xi << 1
        d_approx = 1 - xi
        
        print(f"Xi = {xi:.6e} (weak field: Xi << 1)")
        print(f"D_SSZ (exact) = {d:.15f}")
        print(f"D_SSZ (approx 1-Xi) = {d_approx:.15f}")
        print(f"Difference = {abs(d - d_approx):.6e}")
        
        # Should agree to O(Xi^2)
        assert abs(d - d_approx) < xi**2, "Weak field approximation should hold"
        
        print("\nPhysical Interpretation:")
        print("  -> For Xi << 1: D_SSZ ~ 1 - Xi + O(Xi^2)")
        print("  -> Earth's surface is firmly in weak-field regime")
        print("="*70)
    
    def test_far_field_limit(self):
        """At large r, Xi -> 0 and D_SSZ -> 1."""
        print("\n" + "="*70)
        print("TEST: Far Field Limit")
        print("="*70)
        
        r_far = 1e12  # 1 trillion meters (beyond Pluto)
        
        xi = xi_segment_density(r_far, M_EARTH)
        d = ssz_time_dilation(r_far, M_EARTH)
        
        print(f"Distance: {r_far:.0e} m")
        print(f"Xi = {xi:.6e}")
        print(f"D_SSZ = {d:.15f}")
        
        # Xi should be very small at 1 trillion meters (but not necessarily < 1e-20)
        assert xi < 1e-10, "Xi should be very small at large r"
        assert np.isclose(d, 1.0, rtol=1e-10), "D_SSZ should approach 1"
        
        print("\nPhysical Interpretation:")
        print("  -> Far from mass: spacetime is nearly flat")
        print("  -> Xi -> 0, D_SSZ -> 1 (negligible time dilation)")
        print("="*70)
    
    def test_golden_ratio_constant(self):
        """Verify golden ratio constant."""
        print("\n" + "="*70)
        print("TEST: Golden Ratio Constant")
        print("="*70)
        
        phi_expected = (1 + np.sqrt(5)) / 2
        
        print(f"PHI (constant) = {PHI:.15f}")
        print(f"PHI (calculated) = {phi_expected:.15f}")
        print(f"PHI^2 = {PHI**2:.15f}")
        print(f"PHI + 1 = {PHI + 1:.15f}")
        
        assert np.isclose(PHI, phi_expected, rtol=1e-15)
        assert np.isclose(PHI**2, PHI + 1, rtol=1e-14), "phi^2 = phi + 1"
        
        print("\nPhysical Interpretation:")
        print("  -> Golden ratio is fundamental to SSZ framework")
        print("  -> phi^2 = phi + 1 is the defining property")
        print("  -> Appears in segment structure and time dilation")
        print("="*70)


# =============================================================================
# TEST 10: NUMERICAL STABILITY
# =============================================================================

class TestNumericalStability:
    """Tests for numerical stability and edge cases."""
    
    def test_very_small_height_difference(self):
        """Test with nanometer-scale height differences."""
        print("\n" + "="*70)
        print("TEST: Nanometer Height Difference")
        print("="*70)
        
        q1 = Qubit(id="Q1", x=0, y=0, z=0)
        q2 = Qubit(id="Q2", x=0, y=0, z=1e-9)  # 1 nm higher
        pair = QubitPair(q1, q2)
        
        mismatch = qubit_pair_segment_mismatch(pair, M_EARTH)
        
        print(f"Height difference: 1 nm")
        print(f"Delta Xi: {mismatch['delta_xi']:.6e}")
        print(f"Delta D_SSZ: {mismatch['delta_time_dilation']:.6e}")
        
        assert mismatch['delta_xi'] > 0, "Should detect nm-scale differences"
        assert np.isfinite(mismatch['delta_xi']), "Result should be finite"
        
        print("\nPhysical Interpretation:")
        print("  -> SSZ can resolve nm-scale height differences")
        print("  -> Important for precision qubit placement")
        print("="*70)
    
    def test_large_qubit_array(self):
        """Test with large qubit array."""
        print("\n" + "="*70)
        print("TEST: Large Qubit Array (100 qubits)")
        print("="*70)
        
        qubits = optimize_qubit_array(100, base_height=0, max_separation=0.01)
        uniformity = array_segment_uniformity(qubits, M_EARTH)
        
        print(f"Number of qubits: {len(qubits)}")
        print(f"Xi mean: {uniformity['xi_mean']:.6e}")
        print(f"Uniformity: {uniformity['uniformity']:.6f}")
        
        assert len(qubits) == 100
        assert np.isfinite(uniformity['xi_mean'])
        
        print("\nPhysical Interpretation:")
        print("  -> Framework scales to large qubit arrays")
        print("  -> Uniformity analysis works for any array size")
        print("="*70)
    
    def test_height_to_time_offset(self):
        """Test time offset calculation."""
        print("\n" + "="*70)
        print("TEST: Height to Time Offset")
        print("="*70)
        
        heights = [1.0, 10.0, 100.0, 1000.0]  # meters (larger values for numerical stability)
        
        print(f"{'Height [m]':>12} | {'Time offset/s [ps]':>20}")
        print("-" * 40)
        
        for h in heights:
            dt = height_to_time_offset(h, duration_s=1.0, M=M_EARTH)
            dt_ps = dt * 1e12
            print(f"{h:>12.2f} | {dt_ps:>20.6f}")
            
            assert np.isfinite(dt)
            # Use >= for numerical stability (very small values may round to 0)
            assert dt >= 0, "Time offset should be non-negative for positive height"
        
        print("\nPhysical Interpretation:")
        print("  -> Time offset scales with height")
        print("  -> At 1m: ~0.1 ps/s offset")
        print("  -> At 100m: ~10 ps/s offset")
        print("="*70)


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    print("\n" + "="*70)
    print("SSZ-QUBITS PHYSICS TEST SUITE")
    print("="*70)
    print("Running comprehensive physics validation tests...")
    print("="*70 + "\n")
    
    # Run with pytest
    pytest.main([__file__, "-v", "-s", "--tb=short"])
